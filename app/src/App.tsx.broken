// src/App.tsx
import Sketch from "react-p5";
import p5Types from "p5";

export default function App() {
  let handPose: any;
  let video: any;
  let detections: any[] = [];
  let gestureHistory: { x: number; y: number; time: number; size: number; orientation: string }[] = [];
  let smoothedPositions: { x: number; y: number }[] = [];
  let detectedGesture = "";
  let gestureConfidence = 0;
  let lastGestureTime = 0;
  let currentPalmOrientation = "";
  const historyLength = 30;
  const confidenceThreshold = 0.3; // ml5æ‰‹åŠ¿è¯†åˆ«ç½®ä¿¡åº¦é˜ˆå€¼
  const gestureDebounceTime = 500; // æ‰‹åŠ¿è¯†åˆ«é˜²æŠ–æ—¶é—´(æ¯«ç§’)
  const minVelocity = 2; // æœ€å°é€Ÿåº¦é˜ˆå€¼ï¼Œè¿‡æ»¤é™æ­¢æ—¶çš„æŠ–åŠ¨ 

  const setup = (p5: p5Types, canvasParentRef: Element) => {
    p5.createCanvas(625, 437).parent(canvasParentRef);
    video = p5.createCapture("video");
    video.size(625, 437);
    video.hide();

    setTimeout(async () => {
      const ml5 = (window as any).ml5;
      if (ml5 && ml5.handPose) {
        let options = { maxHands: 1, flipped: false };
        handPose = await ml5.handPose(options);
        handPose.detectStart(video, (results: any) => {
          detections = results;
        });
      }
    }, 2000);
  };

  // æŒ‡æ•°ç§»åŠ¨å¹³å‡æ»¤æ³¢å™¨ (EMA) - æ›´å¹³æ»‘ä¸”å“åº”å¿«
  const applyExponentialSmoothing = (currentPos: { x: number; y: number }, prevSmoothed: { x: number; y: number } | null, alpha: number = 0.3): { x: number; y: number } => {
    if (!prevSmoothed) return currentPos;
    
    return {
      x: alpha * currentPos.x + (1 - alpha) * prevSmoothed.x,
      y: alpha * currentPos.y + (1 - alpha) * prevSmoothed.y
    };
  };

  // è®¡ç®—é€Ÿåº¦å¹¶è¿‡æ»¤é™æ­¢æŠ–åŠ¨
  const calculateVelocity = (history: { x: number; y: number; time: number }[]): number => {
    if (history.length < 2) return 0;
    
    const recent = history.slice(-5);
    if (recent.length < 2) return 0;
    
    const start = recent[0];
    const end = recent[recent.length - 1];
    const deltaX = end.x - start.x;
    const deltaY = end.y - start.y;
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    const timeDelta = end.time - start.time;
    
    return timeDelta > 0 ? (distance / timeDelta) * 1000 : 0; // åƒç´ /ç§’
  };

  // è®¡ç®—æ‰‹æŒæœå‘ - ä½¿ç”¨æ‰‹æŒ‡å’Œæ‰‹è…•çš„å…³é”®ç‚¹
  const calculatePalmOrientation = (keypoints: any[]): string => {
    // æ‰‹éƒ¨å…³é”®ç‚¹ç´¢å¼•ï¼š
    // 0: æ‰‹è…•
    // 4: æ‹‡æŒ‡å°–
    // 8: é£ŸæŒ‡å°–
    // 12: ä¸­æŒ‡å°–
    // 16: æ— åæŒ‡å°–
    // 20: å°æŒ‡å°–
    // 5: é£ŸæŒ‡æ ¹éƒ¨
    // 9: ä¸­æŒ‡æ ¹éƒ¨
    
    const wrist = keypoints[0];
    const thumbTip = keypoints[4];
    const indexTip = keypoints[8];
    const middleTip = keypoints[12];
    const indexBase = keypoints[5];
    const middleBase = keypoints[9];
    
    // è®¡ç®—æ‰‹æŒä¸­å¿ƒï¼ˆä½¿ç”¨é£ŸæŒ‡å’Œä¸­æŒ‡æ ¹éƒ¨çš„ä¸­ç‚¹ï¼‰
    const palmCenterX = (indexBase.x + middleBase.x) / 2;
    const palmCenterY = (indexBase.y + middleBase.y) / 2;
    
    // è®¡ç®—æ‰‹æŒ‡æ–¹å‘å‘é‡ï¼ˆä»æ‰‹è…•åˆ°æ‰‹æŒ‡å°–çš„å¹³å‡ï¼‰
    const fingerDirX = (indexTip.x + middleTip.x) / 2 - palmCenterX;
    const fingerDirY = (indexTip.y + middleTip.y) / 2 - palmCenterY;
    
    // è®¡ç®—æ‹‡æŒ‡ç›¸å¯¹äºæ‰‹æŒçš„ä½ç½®
    const thumbRelX = thumbTip.x - palmCenterX;
    const thumbRelY = thumbTip.y - palmCenterY;
    
    // åˆ¤æ–­æ‰‹æŒæœå‘
    // å¦‚æœæ‹‡æŒ‡åœ¨å·¦è¾¹ï¼Œæ‰‹æŒæœå³ï¼›æ‹‡æŒ‡åœ¨å³è¾¹ï¼Œæ‰‹æŒæœå·¦
    const angle = Math.atan2(fingerDirY, fingerDirX) * 180 / Math.PI;
    const thumbAngle = Math.atan2(thumbRelY, thumbRelX) * 180 / Math.PI;
    
    // è®¡ç®—æ‹‡æŒ‡å’Œæ‰‹æŒ‡çš„ç›¸å¯¹ä½ç½®æ¥åˆ¤æ–­æ‰‹æŒæœå‘
    const crossProduct = fingerDirX * thumbRelY - fingerDirY * thumbRelX;
    
    // æ ¹æ®æ‰‹æŒ‡æœå‘å’Œæ‹‡æŒ‡ä½ç½®åˆ¤æ–­
    if (Math.abs(angle) < 45) {
      // æ‰‹æŒ‡æœå³
      return crossProduct > 0 ? "æ‰‹å¿ƒå‘ä¸‹" : "æ‰‹å¿ƒå‘ä¸Š";
    } else if (Math.abs(angle) > 135) {
      // æ‰‹æŒ‡æœå·¦
      return crossProduct > 0 ? "æ‰‹å¿ƒå‘ä¸Š" : "æ‰‹å¿ƒå‘ä¸‹";
    } else if (angle > 45 && angle < 135) {
      // æ‰‹æŒ‡æœä¸‹
      return crossProduct > 0 ? "æ‰‹å¿ƒå‘å³" : "æ‰‹å¿ƒå‘å·¦";
    } else {
      // æ‰‹æŒ‡æœä¸Š
      return crossProduct > 0 ? "æ‰‹å¿ƒå‘å·¦" : "æ‰‹å¿ƒå‘å³";
    }
  };

  // è®¡ç®—æ‰‹æŒå°ºå¯¸ï¼ˆç”¨äºåˆ¤æ–­å‰åç§»åŠ¨ï¼‰
  const calculateHandSize = (keypoints: any[]): number => {
    // è®¡ç®—æ‰‹æŒå®½åº¦ï¼šæ‹‡æŒ‡æ ¹éƒ¨åˆ°å°æŒ‡æ ¹éƒ¨çš„è·ç¦»
    const thumbBase = keypoints[2]; // æ‹‡æŒ‡æ ¹éƒ¨
    const pinkyBase = keypoints[17]; // å°æŒ‡æ ¹éƒ¨
    
    const width = Math.sqrt(
      Math.pow(thumbBase.x - pinkyBase.x, 2) +
      Math.pow(thumbBase.y - pinkyBase.y, 2)
    );
    
    // è®¡ç®—æ‰‹æŒé•¿åº¦ï¼šæ‰‹è…•åˆ°ä¸­æŒ‡å°–çš„è·ç¦»
    const wrist = keypoints[0];
    const middleTip = keypoints[12];
    
    const length = Math.sqrt(
      Math.pow(middleTip.x - wrist.x, 2) +
      Math.pow(middleTip.y - wrist.y, 2)
    );
    
    // è¿”å›é¢ç§¯ä½œä¸ºå°ºå¯¸åº¦é‡
    return width * length;
  };

  const draw = (p5: p5Types) => {
    p5.image(video, 0, 0, p5.width, p5.height);
    
    if (detections && detections.length > 0) {
      const detection = detections[0];
      
      // æ£€æŸ¥ç½®ä¿¡åº¦
      if (detection.score && detection.score < confidenceThreshold) {
        return; // ç½®ä¿¡åº¦å¤ªä½ï¼Œè·³è¿‡æ­¤å¸§
      }
      
      drawKeypoints(p5, detections);
      
      // è·å–æ‰‹è…•ä½ç½®ï¼ˆå…³é”®ç‚¹0ï¼‰ä½œä¸ºæ‰‹çš„ä¸­å¿ƒç‚¹
      const wrist = detection.keypoints[0];
      
      // è®¡ç®—æ‰‹æŒæœå‘å’Œå°ºå¯¸
      currentPalmOrientation = calculatePalmOrientation(detection.keypoints);
      const handSize = calculateHandSize(detection.keypoints);
      
      // åº”ç”¨æŒ‡æ•°å¹³æ»‘æ»¤æ³¢
      const prevSmoothed = smoothedPositions.length > 0 ? smoothedPositions[smoothedPositions.length - 1] : null;
      const smoothedPos = applyExponentialSmoothing({ x: wrist.x, y: wrist.y }, prevSmoothed, 0.3);
      smoothedPositions.push(smoothedPos);
      
      // é™åˆ¶å¹³æ»‘ä½ç½®å†å²é•¿åº¦
      if (smoothedPositions.length > historyLength) {
        smoothedPositions.shift();
      }
      
      // è®°å½•è½¨è¿¹ï¼ˆä½¿ç”¨å¹³æ»‘åçš„ä½ç½®ã€å°ºå¯¸å’Œæœå‘ï¼‰
      gestureHistory.push({
        x: smoothedPos.x,
        y: smoothedPos.y,
        time: Date.now(),
        size: handSize,
        orientation: currentPalmOrientation
      });
      
      // ä¿æŒå†å²é•¿åº¦
      if (gestureHistory.length > historyLength) {
        gestureHistory.shift();
      }
      
      // è®¡ç®—é€Ÿåº¦ï¼Œè¿‡æ»¤é™æ­¢æ—¶çš„å™ªéŸ³
      const velocity = calculateVelocity(gestureHistory);
      
      // è¯†åˆ«åŠ¨æ€æ‰‹åŠ¿ï¼ˆéœ€è¦è¶³å¤Ÿçš„å†å²å’Œæœ€å°é€Ÿåº¦ï¼‰
      const currentTime = Date.now();
      if (gestureHistory.length >= historyLength && 
          velocity > minVelocity &&
          currentTime - lastGestureTime > gestureDebounceTime) {
        const newGesture = recognizeGestureWithOrientation(gestureHistory);
        if (newGesture) {
          detectedGesture = newGesture;
          gestureConfidence = Math.min(1, velocity / 100); // åŸºäºé€Ÿåº¦çš„ç½®ä¿¡åº¦
          lastGestureTime = currentTime;
        }
      }
      
      // ç»˜åˆ¶è½¨è¿¹ï¼ˆå¹³æ»‘åçš„ï¼‰
      drawTrail(p5, gestureHistory);
      
      // æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
      p5.fill(255);
      p5.textSize(12);
      p5.textAlign(p5.LEFT, p5.TOP);
      p5.text(`é€Ÿåº¦: ${velocity.toFixed(1)} px/s`, 10, 10);
      p5.text(`ç½®ä¿¡åº¦: ${(gestureConfidence * 100).toFixed(0)}%`, 10, 30);
      p5.text(`æ‰‹æŒæœå‘: ${currentPalmOrientation}`, 10, 50);
      p5.text(`æ‰‹æŒå°ºå¯¸: ${handSize.toFixed(0)}`, 10, 70);
    } else {
      gestureHistory = [];
      smoothedPositions = [];
      detectedGesture = "";
      currentPalmOrientation = "";
    }
    
    // æ˜¾ç¤ºè¯†åˆ«åˆ°çš„æ‰‹åŠ¿
    if (detectedGesture) {
      p5.fill(255, 255, 0);
      p5.noStroke();
      p5.textSize(32);
      p5.textAlign(p5.CENTER, p5.TOP);
      p5.text(detectedGesture, p5.width / 2, 20);
    }
  };

  const drawKeypoints = (p5: p5Types, detections: any[]) => {
    p5.noStroke();
    p5.fill(0, 255, 0);
    for (let i = 0; i < detections.length; i++) {
      let detection = detections[i];
      for (let j = 0; j < detection.keypoints.length; j++) {
        let keypoint = detection.keypoints[j];
        p5.circle(keypoint.x, keypoint.y, 5);
      }
    }
  };

  const drawTrail = (p5: p5Types, history: { x: number; y: number }[]) => {
    p5.noFill();
    p5.stroke(255, 0, 255);
    p5.strokeWeight(3);
    p5.beginShape();
    for (let i = 0; i < history.length; i++) {
      p5.vertex(history[i].x, history[i].y);
    }
    p5.endShape();
  };

  const recognizeGestureWithOrientation = (history: { x: number; y: number; time: number; size: number; orientation: string }[]): string => {
    if (history.length < 15) return "";
    
    const start = history[0];
    const end = history[history.length - 1];
    const deltaX = end.x - start.x;
    const deltaY = end.y - start.y;
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    
    // è®¡ç®—å°ºå¯¸å˜åŒ–ï¼ˆåˆ¤æ–­å‰åç§»åŠ¨ï¼‰
    const sizeChange = end.size - start.size;
    const sizeChangePercent = (sizeChange / start.size) * 100;
    
    // è·å–ä¸»è¦æ‰‹æŒæœå‘ï¼ˆä½¿ç”¨æœ€è¿‘å‡ å¸§çš„ï¼‰
    const recentOrientations = history.slice(-10).map(h => h.orientation);
    const dominantOrientation = getMostFrequent(recentOrientations);
    
    // åŠ¨æ€é˜ˆå€¼ï¼šæ ¹æ®æ—¶é—´è°ƒæ•´è·ç¦»è¦æ±‚
    const timeDelta = end.time - start.time;
    const minDistance = Math.max(60, timeDelta / 20);
    
    // ä¼˜å…ˆæ£€æµ‹å‰åç§»åŠ¨ï¼ˆåŸºäºå°ºå¯¸å˜åŒ–ï¼‰
    if (Math.abs(sizeChangePercent) > 15 && distance < 80) { // å°ºå¯¸å˜åŒ–å¤§ä½†ä½ç½®å˜åŒ–å°
      if (sizeChange > 0) {
        return `ğŸ‘‹ æ‰‹æŒ${dominantOrientation} - å‘å‰`;
      } else {
        return `âœ‹ æ‰‹æŒ${dominantOrientation} - å‘å`;
      }
    }
    
    // æ£€æµ‹å¹³é¢ç§»åŠ¨ï¼ˆä¸Šä¸‹å·¦å³ï¼‰
    if (distance < minDistance) return "";
    
    // è®¡ç®—ç§»åŠ¨è§’åº¦
    const angle = Math.atan2(deltaY, deltaX);
    const angleDeg = (angle * 180 / Math.PI + 360) % 360;
    
    // æ£€æµ‹æ–¹å‘æ€§æ‰‹åŠ¿ - ç»“åˆæ‰‹æŒæœå‘
    const pathStraightness = calculatePathStraightness(history);
    
    if (pathStraightness > 0.65) { // è·¯å¾„è¶³å¤Ÿç›´
      // æ°´å¹³æ–¹å‘
      if ((angleDeg < 30 || angleDeg > 330)) {
        return `ğŸ‘‰ æ‰‹æŒ${dominantOrientation} - å‘å³`;
      } else if (angleDeg > 150 && angleDeg < 210) {
        return `ğŸ‘ˆ æ‰‹æŒ${dominantOrientation} - å‘å·¦`;
      }
      // å‚ç›´æ–¹å‘
      else if (angleDeg > 60 && angleDeg < 120) {
        return `ğŸ‘‡ æ‰‹æŒ${dominantOrientation} - å‘ä¸‹`;
      } else if (angleDeg > 240 && angleDeg < 300) {
        return `ğŸ‘† æ‰‹æŒ${dominantOrientation} - å‘ä¸Š`;
      }
    }
    
    // å…¶ä»–æ‰‹åŠ¿æ£€æµ‹
    if (isWaving(history)) {
      return `ğŸ‘‹ æ‰‹æŒ${dominantOrientation} - æŒ¥æ‰‹`;
    }
    
    if (isCircular(history)) {
      return `â­• æ‰‹æŒ${dominantOrientation} - ç”»åœˆ`;
    }
    
    return "";
  };

  // è·å–æ•°ç»„ä¸­æœ€å¸¸å‡ºç°çš„å…ƒç´ 
  const getMostFrequent = (arr: string[]): string => {
    const frequency: { [key: string]: number } = {};
    let maxFreq = 0;
    let mostFrequent = "";
    
    for (const item of arr) {
      frequency[item] = (frequency[item] || 0) + 1;
      if (frequency[item] > maxFreq) {
        maxFreq = frequency[item];
        mostFrequent = item;
      }
    }
    
    return mostFrequent;
  };
    if (history.length < 15) return "";
    
    const start = history[0];
    const end = history[history.length - 1];
    const deltaX = end.x - start.x;
    const deltaY = end.y - start.y;
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    
    // åŠ¨æ€é˜ˆå€¼ï¼šæ ¹æ®æ—¶é—´è°ƒæ•´è·ç¦»è¦æ±‚
    const timeDelta = end.time - start.time;
    const minDistance = Math.max(80, timeDelta / 20); // æ—¶é—´è¶Šé•¿ï¼Œè¦æ±‚è·ç¦»è¶Šå¤§
    
    // é˜ˆå€¼ï¼šè‡³å°‘ç§»åŠ¨ä¸€å®šè·ç¦»æ‰ç®—æœ‰æ•ˆæ‰‹åŠ¿
    if (distance < minDistance) return "";
    
    // æ£€æµ‹æŒ¥æ‰‹ï¼ˆå·¦å³æ‘†åŠ¨ï¼‰- æé«˜ä¼˜å…ˆçº§
    if (isWaving(history)) {
      return "ğŸ‘‹ æŒ¥æ‰‹";
    }
    
    // æ£€æµ‹ç”»åœˆ
    if (isCircular(history)) {
      return "â­• ç”»åœˆ";
    }
    
    // è®¡ç®—è§’åº¦ï¼ˆå¼§åº¦ï¼‰
    const angle = Math.atan2(deltaY, deltaX);
    const angleDeg = (angle * 180 / Math.PI + 360) % 360;
    
    // æ£€æµ‹æ–¹å‘æ€§æ‰‹åŠ¿ - ä½¿ç”¨è§’åº¦æ¥æ›´å‡†ç¡®åˆ¤æ–­
    // ä½¿ç”¨æ›´å®½æ¾çš„è§’åº¦èŒƒå›´ï¼Œä½†è¦æ±‚è·¯å¾„æ›´ç›´
    const pathStraightness = calculatePathStraightness(history);
    
    if (pathStraightness > 0.7) { // è·¯å¾„è¶³å¤Ÿç›´
      // æ°´å¹³æ–¹å‘ (å³: 0Â°Â±30Â°, å·¦: 180Â°Â±30Â°)
      if ((angleDeg < 30 || angleDeg > 330)) {
        return "ğŸ‘‰ å‘å³æ»‘åŠ¨";
      } else if (angleDeg > 150 && angleDeg < 210) {
        return "ğŸ‘ˆ å‘å·¦æ»‘åŠ¨";
      }
      // å‚ç›´æ–¹å‘ (ä¸‹: 90Â°Â±30Â°, ä¸Š: 270Â°Â±30Â°)
      else if (angleDeg > 60 && angleDeg < 120) {
        return "ğŸ‘‡ å‘ä¸‹æ»‘åŠ¨";
      } else if (angleDeg > 240 && angleDeg < 300) {
        return "ï¿½ å‘ä¸Šæ»‘åŠ¨";
      }
    }
    
    return "";
  };

  // è®¡ç®—è·¯å¾„çš„ç›´çº¿åº¦ï¼ˆ0-1ï¼Œ1è¡¨ç¤ºå®Œå…¨ç›´çº¿ï¼‰
  const calculatePathStraightness = (history: { x: number; y: number }[]): number => {
    if (history.length < 3) return 0;
    
    const start = history[0];
    const end = history[history.length - 1];
    const directDistance = Math.sqrt(
      Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2)
    );
    
    // è®¡ç®—å®é™…è·¯å¾„é•¿åº¦
    let pathLength = 0;
    for (let i = 1; i < history.length; i++) {
      pathLength += Math.sqrt(
        Math.pow(history[i].x - history[i - 1].x, 2) +
        Math.pow(history[i].y - history[i - 1].y, 2)
      );
    }
    
    return pathLength > 0 ? directDistance / pathLength : 0;
  };

  const isWaving = (history: { x: number; y: number }[]): boolean => {
    // æ£€æµ‹æ˜¯å¦æœ‰å·¦å³æ‘†åŠ¨ï¼ˆè‡³å°‘2æ¬¡æ–¹å‘æ”¹å˜ï¼‰
    // ä½¿ç”¨æ›´å¤§çš„é‡‡æ ·é—´éš”æ¥é¿å…å™ªéŸ³å¯¼è‡´çš„è¯¯åˆ¤
    const sampleInterval = 3;
    let directionChanges = 0;
    let prevDirection = 0;
    let peaks = 0; // è®°å½•æ³¢å³°æ³¢è°·æ•°é‡
    
    for (let i = sampleInterval; i < history.length; i += sampleInterval) {
      const deltaX = history[i].x - history[i - sampleInterval].x;
      const currentDirection = deltaX > 5 ? 1 : deltaX < -5 ? -1 : 0; // å¢åŠ é˜ˆå€¼é¿å…å™ªéŸ³
      
      if (currentDirection !== 0 && currentDirection !== prevDirection && prevDirection !== 0) {
        directionChanges++;
        peaks++;
      }
      
      if (currentDirection !== 0) {
        prevDirection = currentDirection;
      }
    }
    
    // éœ€è¦è‡³å°‘2æ¬¡æ˜æ˜¾çš„æ–¹å‘æ”¹å˜ï¼Œä¸”Yè½´å˜åŒ–ä¸èƒ½å¤ªå¤§ï¼ˆä¿æŒæ°´å¹³ï¼‰
    const deltaY = Math.abs(history[history.length - 1].y - history[0].y);
    const deltaX = Math.abs(history[history.length - 1].x - history[0].x);
    
    return directionChanges >= 2 && peaks >= 2 && deltaY < deltaX * 0.8;
  };

  const isCircular = (history: { x: number; y: number }[]): boolean => {
    // æ”¹è¿›çš„ç”»åœˆæ£€æµ‹ï¼šæ£€æŸ¥è½¨è¿¹æ˜¯å¦å½¢æˆé—­åˆè·¯å¾„
    if (history.length < 20) return false;
    
    const start = history[0];
    const end = history[history.length - 1];
    const startEndDist = Math.sqrt(
      Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2)
    );
    
    // è®¡ç®—è½¨è¿¹æ€»é•¿åº¦
    let totalDist = 0;
    for (let i = 1; i < history.length; i++) {
      totalDist += Math.sqrt(
        Math.pow(history[i].x - history[i - 1].x, 2) +
        Math.pow(history[i].y - history[i - 1].y, 2)
      );
    }
    
    // è®¡ç®—ä¸­å¿ƒç‚¹
    const centerX = history.reduce((sum, p) => sum + p.x, 0) / history.length;
    const centerY = history.reduce((sum, p) => sum + p.y, 0) / history.length;
    
    // è®¡ç®—æ¯ä¸ªç‚¹åˆ°ä¸­å¿ƒçš„è·ç¦»
    const distances = history.map(p => 
      Math.sqrt(Math.pow(p.x - centerX, 2) + Math.pow(p.y - centerY, 2))
    );
    
    // è®¡ç®—è·ç¦»çš„æ ‡å‡†å·®ï¼ˆåˆ¤æ–­æ˜¯å¦æ˜¯åœ†å½¢ï¼‰
    const avgDistance = distances.reduce((sum, d) => sum + d, 0) / distances.length;
    const variance = distances.reduce((sum, d) => sum + Math.pow(d - avgDistance, 2), 0) / distances.length;
    const stdDev = Math.sqrt(variance);
    
    // æ£€æŸ¥è§’åº¦å˜åŒ–ï¼ˆæ˜¯å¦è½¬äº†ä¸€åœˆï¼‰
    let totalAngleChange = 0;
    for (let i = 1; i < history.length; i++) {
      const angle1 = Math.atan2(history[i - 1].y - centerY, history[i - 1].x - centerX);
      const angle2 = Math.atan2(history[i].y - centerY, history[i].x - centerX);
      let angleDiff = angle2 - angle1;
      
      // å¤„ç†è§’åº¦è·³å˜
      if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
      if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
      
      totalAngleChange += Math.abs(angleDiff);
    }
    
    // åˆ¤æ–­æ¡ä»¶ï¼š
    // 1. èµ·ç‚¹ç»ˆç‚¹å¾ˆè¿‘
    // 2. æ€»è·¯å¾„å¾ˆé•¿
    // 3. è·ç¦»æ ‡å‡†å·®å°ï¼ˆæ¥è¿‘åœ†å½¢ï¼‰
    // 4. æ€»è§’åº¦å˜åŒ–æ¥è¿‘2Ï€ï¼ˆè½¬äº†ä¸€åœˆï¼‰
    return startEndDist < 60 && 
           totalDist > 200 && 
           stdDev / avgDistance < 0.3 &&
           totalAngleChange > Math.PI * 1.5; // è‡³å°‘è½¬äº†å¤§åŠåœˆ
  };

  return <Sketch setup={setup} draw={draw} />;
}